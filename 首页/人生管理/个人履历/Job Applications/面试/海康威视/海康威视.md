任职要求

IIC

SPI

UART

架构

操作系统原理

陷阱

故障

终止

进程

进程之间通信（IPC）

线程同步

static

const

volatile

指针数组/数组指针

一、数据结构(二叉树，链表，队列，栈)，手写链表的插入，中间插入

二、GDB用过吗，具体解决问题的实例

三、socket通信的过程，全部函数写一下

选择题

1、若有8个待排序元素，采用冒泡排序和插入排序最大时间复杂度分别是（）。

2、下面程序中b的值是（）。

3、下列代码中数组data最终的数据是哪个（）。

4、下面哪个命令用来卸载一个内核模块？

5、使用快速排序对n个数进行排序，其在最佳情况、平均情况、最差情况下的时间复杂度分别是（）。

6、关于互斥锁的如下表述错误的是（）。

7、Linux在某目录下查找某字符串通常如下哪个指令？

8、多个进程按照顺序逐一来访问某个资源，这种制约关系称之为（）。

9、支持多道程序的操作系统在运行过程中，不断地选择新进程运行来实现CPU的共享，但其中（）不是引起操作系统选择新进程的直接原因。

10、（）是操作系统分配资源的基本单位。

11、执行下述的main函数后，输出结果是多少？

12、以下能对二维数组a进行完整初始化的语句是（）。

13、下面程序的输出值，正确的是（）。

14、下面程序的输出值，正确的是（）。

15、假如test指针的值为0x12345678，则表达式test_p[1]的指针地址值是多少？

16、在C语言程序中，下面程序运行后，n的值是多少？

17、下面那个操作可以将flag的bit[2]（假定bit[31...0]对应flag的32位）置0？

18、下面程序的运行结果为？

19、对于堆、栈、队列描述错误的是（）。

20、以下对字符数组test赋值方式错误的是（）。

21、可用于中断下半段处理的处理机制有（）。

22、有函数fun()定义如下，在main函数调用fun函数执行过程中，使用了哪些函数参数传递方式？

23、关于链表，描述正确的选项有（）。

24、对运算符优先级的判断，正确的是（）。

25、能在Linux内核态执行的是（）。

简答题

1、Linux驱动连接硬件与应用，根据你对驱动加载的理解，回答如下问题：

2、设计或开发Linux操作系统的内核时，你会考虑哪些基本的管理模块，并描述其作用。

### **任职要求**

1、本科及以上学历，计算机、电子信息、通信等相关专业，对英文技术文档有较好的阅读理解能力；2、熟练使用C语言，有汇编语言或脚本语言的使用经验；3、熟悉常用总线和接口协议，如I2C、SPI、UART，了解基本网络知识；4、了解单片机、ARM、DSP、X86等至少一种芯片架构及组成；5、了解操作系统原理，理解中断、进程、内存等基本概念，有Linux/RTOS上驱动或应用程序开发经验优先。

  

对海康威视的了解

安防，互联网，人工智能

  

Linux内核的启动过程

  

  

您好，我叫陈达，来自哈尔滨工业大学威海校区，我的专业是测控技术与仪器，成绩在专业前15%，在大一的时候参加全国大学生电子设计大赛中获得过山东省一等奖，在大二暑期参加了山东新北洋的暑期实习，在大学三年中担任班级组织委员，曾获多次奖学金，希望得到一份理想的工作

  

## IIC

- 两线协议，分别为SCL,SDA线，SCL为时钟线，SDA为数据线，同步通信，半双工，多主机通信，（可以在通信中改变主机）每个IIC设备都有一个设备地址用于识别身份，主机从机以及地址可以配置，比如之前用过的fpc8591，IIC地址的1-3位可以通过引脚电平进行配置，标准模式，传输速率为100kb每秒，快速模式下，可以达到400kb每秒，
- IIC协议没有规定总线上device最大数目，但是规定了总线电容不能超过400pF。管脚都是有输入电容的，PCB上也会有寄生电容，所以会有一个限制。**实际设计中经验值大概是不超过8个器件。**
    
    总线之所以规定电容大小是因为，IIC的OD要求外部有电阻上拉，电阻和总线电容产生了一个RC延时效应，电容越大信号的边沿就越缓，有可能带来信号质量风险。
    
    传输速度越快，信号的窗口就越小，上升沿下降沿时间要求更短更陡峭，所以RC乘积必须更小
    
- 协议：只有主机能够发送起始和结束信号，
    - 起始信号，scl为高电平，sda向下跳变，
    - 结束信号，scl为高电平，sda向上跳变，
    - 在scl的低电平状态，数据改变，在scl的高电平状态，数据必须保持稳定，以便在读取数据的时候不会发生变化
    - IIC一次接受或发送8位数据，每接受完8位数据后，需要给出一个应答信号，应答信号定义为，在8位信号发送完之后的下一个scl高电平状态，如果为0表示应答，如果为1表示无应答
- 写模式：
    - 首先是主机发送起始信号，然后发送第一个字节，该字节包含7位的从机地址，一个一个写位，然后等待主机发送应答信号，然后在向主机发送数据在等待应答信号，直到最后通信结束，主机发送结束信号
- 读模式：
    - 首先主机发送起始信号，然后发送第一个字节，该字节包含7为从机地址一个读位，然后等待主机发送应答信号，在接受到应答信号后继续接受从机发送的数据，并发送应答信号，通信结束后，主机发送结束信号
- 读写模式：
    - 在主机改变读写模式时，不产生结束信号，而是重新发送起始信号以及对应的读写地址
- 关于具体的芯片时序之间的问题，需要察看具体的数据手册。

## SPI

- 四线协议，MOSI（主设备输出从设备输入）,MISO（主设备输入从设备输出）,SCLK（同步时钟线，由主设备控制）,CS（片选线，不同的io端口），全双工，同步，
- 通信模式：CPOL(时钟极性),CPHA（时钟相位）
    - CPOL=0，sclk处于0时为空闲状态，CPOL=1，sclk处于1时为空闲状态
    - CPHA=0,数据采样在第一个边沿，数据发送在第二个边沿，CPHA=1,数据采样在第2个边沿，数据发送在第1个边沿，
    - 00
    - 01
    - 10
    - 11
- 没有像iic那样的应答机制

## UART

- 一条线的协议，如果要同时实现收发功能，可以可以外加一条线，分别为，rxd和tex
- 波特率：因为没有时钟信号，所以双方要约定相同的波特率来对信号的长度进行划分，
- 起始位：通信线拉低：4800，9600，19200，115200，
- 校验位：纠错
- 停止位：可以配置成1，1.5，2bit，信号管脚保持相应位时长的高电平
- 232:+3-+15为0，-3—15为1，全双工，距离短
- 485:+2-+6为0，-2—6为1，差分信号，半双工

  

## 架构

- 中央处理单元（CPU）主要由运算器、控制器、寄存器三部分组成，从字面意思看运算器就是起着运算的作用，控制器就是负责发出CPU每条指令所需要的信息，寄存器就是保存运算或者指令的一些临时文件
- x86采用cisc（复杂指令集）arm采用（risc）精简指令集
- arm功耗更低
- arm拥有两条总线，一条是AXI高性能系统总线，一条是APB低功耗外设总线，apb总线用于链接速度较低的外围设备，AXI总线用于链接芯片内部存储器和其他告诉设备，类似计算机中的南桥，北桥，北桥链接告诉设备，南桥连接低速设备，

  

  

  

## 操作系统原理

五大组成：运算器，存储器，控制器（cpu），输入设备，输出设备

运算器包含算数单元和逻辑单元，称为ALU

  

  

操作系统主要实现：进程，虚拟内存，和文件。

文件是对IO设备的抽象，

虚拟内存是对主存和磁盘IO设备的抽象

进程是对处理器，主存和IO设备的抽象（对一个正在运行的程序的抽象）。

虚拟机：对整个计算机的抽象，包括操作系统，处理器和程序

操作系统的上下文切换：进程切换表现为同时有很多进程在执行。

上下文：进程运行所需的所有状态信息。

操作系统内核负责切换进程

小端法：最低有效字节在前

大端法：最高有效字节在前

  

![[unnamed.png]]

已经初始化的数据放在.data中，未初始化的数据放在.bss中

并发：一个同时具有多个活动的系统

并行：用并发来时一个系统更快

  

系统启动时，操作系统分配和和初始化一张称为异常表的状态表。

异常区别于过程调用：

  

  

异常的类型：

- 中断(interrupt)
- 陷阱(trap)
- 故障(fault)
- 终止(abort)

  

中断是异步发生的，陷阱，故障和终止时同步发生的，是执行当前指令的结果，把这类指令称为故障指令

### 陷阱

陷阱是有意的异常

最重要的用途是在用户程序和内核之间提供一个向过程一样的接口，叫做系统调用

  

  

### 故障

故障是由错误情况引起的，可能被故障处理程序修正，如果修复成功，就将控制返回到引起故障的指令，从而重新执行它，否则处理程序返回内核中的abort例程，abort例程会终止引起故障的应用程序。

  

  

  

### 终止

终止是不可回复的致命错误造成的错误，从不将控制权返回给应用程序。

  

  

每个系统调用都有一个都有一个唯一的整数号，对应于一个到内核中的跳转表的偏移量，（跳转表，不是异常表）

  

C语言提供了一组包装函数将系统调用包装起来，称为系统级函数。

  

所有的linux系统调用的参数都是通过通用寄存器而不是栈传递的。给

  

### 进程

一个执行中程序的实例

系统中的每一个进程都运行在某个进程的上下文中，上下文是程序正确运行所需的状态组成，这个状态包括存放在内存中的程序的代码和数据，他的栈，通用目的寄存器中的内容，程序计数器，环境变量和打开文件描述符的几何。

  

进程提供给应用程序的关键抽象：

- 一个独立的逻辑控制流，它提供一个假象：我们的程序独占的使用处理器
- 一个私有的地址空间，好像我们的程序独立的使用内存系统。

  

并发流：一个逻辑流的执行在时间上与另一个流重叠（生命周期重叠）

并发：多个流并发的执行的一般现象

并行流：两个流并发的运行在不同的处理器核或计算机上。

  
进程与线程  

  

1. 进程是资源分配的最小单位。

2. 线程是程序执行的最小单位，也是处理器调度的基本单位，但进程不是，两者均可并发执行。

3. 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据，使用相同的地址空间，因此，CPU切换一个线程的花费远比进程小很多，同时创建一个线程的开销也比进程小很多。

4. 线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也跟着死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。

5. 进程切换时，消耗的资源大，效率高。所以涉及到频繁的切换时，使用线程要好于进程。同样如果要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程。

6. 执行过程：每个独立的进程有一个程序运行的入口、顺序执行序列和程序入口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。

**优缺点：**

线程执行开销小，但是不利于资源的管理和保护。线程适合在SMP机器（双CPU系统）上运行。

进程执行开销大，但是能够很好的进行资源管理和保护，可以跨机器迁移。

**何时使用多进程，何时使用多线程？**

对资源的管理和保护要求高，不限制开销和效率时，使用多进程。

要求效率高，频繁切换时，资源的保护管理要求不是很高时，使用多线程。

  

  

## 进程之间通信（IPC）

- 管道(pipe)，流管道(s_pipe)，有名管道(FIFO)
- 信号
- 消息队列
- 共享内存
- 信号量
- 套接字(socket)

  

  

## 线程同步

- 互斥锁
- 读写锁
- 条件变量
- 信号量
- 令牌

  

  

  

  

套接字的唯一标识符：端口号。

一个udp套接字是由一个二元组来全面标识的，该二元组包含一个目的ip地址和一个目的端口地址。

tcp套接字是由一个四元组来标识的：源ip地址，源端口号，目的ip地址，目的端口号。与udp不同，两个具有不同源ip地址和端口号的到达tcp报文将被定向到两个不同的套接字，除非携带了初始创建连接的请求。

  

  

### static

1. **定义全局静态变量**：在全局变量前面加上关键字static，该全局变量变成了全局静态变量。全局静态变量有以下特点。a.在全局区分配内存。b.如果没有初始化，其默认值为0.c.该变量在本文件内从定义开始到文件结束可见。
2. **定义局部静态变量**：在局部变量前面加上关键字static，其特点如下：a.该变量在全局数据区分配内存。b.它始终驻留在全局数据区，直到程序运行结束。c. 其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束。
3. **定义静态函数**：在函数返回类型前加上static关键字，函数即被定义为静态函数，其特点如下：
    
    a.静态函数只能在本源文件中使用
    
    b.在文件作用域中声明的inline函数默认为static类型
    

用static定义的全局和局部静态变量的区别是，全局的静态变量的作用域和可见域都是从文件的定义开始到整个文件结束；而局部的静态变量可见域是从文件的定义开始到整个文件结束，作用域是从该语句块的定义开始到该语句块结束。

static关键字定义静态常量，存储在系统的全局初始化区

### const

可以定义const常量，具有不可变性。

c语言中const全局变量存储在只读数据段，编译期最初将其保存在符号表中，第一次使用时为其分配内存，在程序结束时释放。

==const 从左向右结合，不考虑定义符int ，float等==

  

  

  

### volatile

一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。

例如中断改变寄存器数据；

共享内存

汇编的任意操作

  

## 指针数组/数组指针

==‘[]’的优先级比'*'的优先级高==

  

### **一、数据结构(二叉树，链表，队列，栈)，手写链表的插入，中间插入**

### **二、GDB用过吗，具体解决问题的实例**

GDB是UNIX及Linux下的调试工具，常见的实例是和vscode配合调试单片机或ARM。

### **三、socket通信的过程，全部函数写一下**

服务器端socket(创建socket) --> bind(绑定socket和端口号) --> listen(监听该端口号) --> accept(等待接受客户端连接请求) --> accept(接收来自客户端的连接请求) --> read,write(读取数据和返回数据) --> close(关闭socket)

客户端socket(创建socket) --> connect(连接指定的端口) --> read,write(读取数据和返回数据) --> close(关闭socket)

  

  

  

1、考察字节对齐

2、Soc芯片的相关设计，不会

3、字符串反转

4、考察测试驱动编程概念、步骤、优点，缺点

5、TCP与UDP的区别，举出应用它们的例子，画出TCP释放四次握手示意图（没画出来

[![](http://static.blog.csdn.net/xheditor/xheditor_emot/default/sad.gif)](http://static.blog.csdn.net/xheditor/xheditor_emot/default/sad.gif)

）

7、考察C语言volatile关键字的使用，以及使用volatile分别定义整型和指针类型，并且给出一段代码，问代码有何风险

```Plain
int flag = 0;
 
void doSomething()
{
  start:
    if(flag) goto start;
}
```

8、解释n&(n-1) == 0是用来判断什么

附加题：

有二十瓶药，其中19瓶的药品是1g/粒，一瓶有问题，是1.1g/粒，有一个非常精准的天平，只称量1次，找出有问题的那瓶

这道题不难，对20瓶编号1--20，第i瓶取出i粒，称量，多出的重量（g）乘以10即可得到有问题的瓶编号

  

  

  

海康威视嵌入式软件工程师的题目只包含两个部分选择题和简答题，也就是说，没有编程题！

照样是C语言基础的题量最多了，又因为是BSP方向，所以关于Linux操作系统和驱动方面的题目可能页会比较多一点，但是就题目的总体难度而言，也并不是特别难。但如果对Linux、驱动方面不是很了解的话，估计会很吃亏的。

# **选择题**

### **1、若有8个待排序元素，采用冒泡排序和插入排序最大时间复杂度分别是（）。**

64、24

64、64

16、64

16、16

KEY：B

解答：9大内部排序的时间复杂度和空间复杂度如下表所示：

|分类|方法|时间复杂度|空间复杂度|稳定性|
|---|---|---|---|---|
|[[最好]]|最坏|平均|||
|[[交换排序]]|交换排序|O(n)|O()|O()|
|[[冒泡排序]]|O(n)|O()|O()|O(1)|
|[[快速排序]]|O()|O()|O()|O()|
|[[插入排序]]|直接插入排序|O(n)|O()|O()|
|[[希尔排序]]||O()|O()|O(1)|
|[[选择排序]]|简单选择排序|O()|O()|O()|
|[[堆排序]]|O()|O()|O()|O(1)|
|[[其他]]|归并排序|O()|O()|O()|
|[[计数排序]]|O(d(r+n))|O(d(r+n))|O(d(r+n))|O(r)|

  
  

### **2、下面程序中b的值是（）。**

```Plain
int a[15] = { 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 };
int *p = &a[5];
int b = p[7];
```

14

13

11

12

KEY：B

### **3、下列代码中数组data最终的数据是哪个（）。**

```Plain
\#define MAX_DATA_SIZE (10)
 
int main()
{
	unsigned int i = 0;
	unsigned char data[MAX_DATA_SIZE] = { 1,2,3,4,5,6,7,8,9,0 };
 
	memcpy(&data[2], data, MAX_DATA_SIZE / 2);
 
	return 0;
}
```

1234567890

1212121890

1212345890

其他结果都不对

KEY：D

解答：由于本题中data数组里直接放的是数字，直接强制转化为char类型，按照ASCII码进行查询，显然不会是这些数字了。也就是说，如果改成以下的定义：

```Plain
unsigned char data[MAX_DATA_SIZE] = { '1','2','3','4','5','6','7','8','9','0' };
```

那么答案就是C了。

### **4、下面哪个命令用来卸载一个内核模块？**

modprobe

delmod

unmod

rmmod

KEY：D

### **5、使用快速排序对n个数进行排序，其在最佳情况、平均情况、最差情况下的时间复杂度分别是（）。**

n、nlogn、nlogn

nlogn、nlogn、n^2

nlogn、nlogn、nlogn

n、nlogn、n^2

KEY：B

### **6、关于互斥锁的如下表述错误的是（）。**

互斥锁的加锁和解锁必须由同一线程分别对应使用

互斥锁只能为0/1

互斥锁的解锁过程不需要关心顺序，只需要成对使用即可

互斥锁用于线程的互斥

KEY：C

解答：互斥量和信号量的区别：

- **互斥量用于线程的互斥，信号量用于线程的同步。这是互斥量和信号量的根本区别，也就是互斥和同步之间的区别；**
- **互斥量值只能为0/1，信号量值可以为非负整数。也就是说，一个互斥量只能用于一个资源的互斥访问，它不能实现多个资源的多线程互斥问题。信号量可以实现多个同类资源的多线程互斥和同步。当信号量为单值信号量是，也可以完成一个资源的互斥访问；**
- **互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。**

这里区分一下互斥和同步：

- **互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的；**
- **同步：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。**

参考文章：[线程同步（互斥锁与信号量的作用与区别）](https://www.cnblogs.com/leijiangtao/p/4684331.html)。

### **7、Linux在某目录下查找某字符串通常如下哪个指令？**

find

grep

cat

其他都不对

KEY：A

解答：Linux的find命令用来在指定目录下查找文件，可以使用-name选项来完成：

```Plain
find /home -name "*.txt"            //不忽略大小写
find /home -iname "*.txt"            //忽略大小写
```

### **8、多个进程按照顺序逐一来访问某个资源，这种制约关系称之为（）。**

调度

协同

互斥

同步

KEY：D

### **9、支持多道程序的操作系统在运行过程中，不断地选择新进程运行来实现CPU的共享，但其中（）不是引起操作系统选择新进程的直接原因。**

运行进程要等待某一事件发生

运行进程的时间片用完

有新进程进入就绪状态

运行进程出错

KEY：C

解答：运行进程时间片用完，进程运行出错，运行进程阻塞（也就是等待某一事件发生）都会使操作系统选择新进程，但有新进程进入就绪状态不会影响其他进程状态变化。

### **10、（）是操作系统分配资源的基本单位。**

进程

程序

线程

指令

KEY：A

### **11、执行下述的main函数后，输出结果是多少？**

```Plain
int main()
{
	int i = 10;
 
	switch(i) {
		case 9:i++;
		case 10:i++;
		case 11:i++;
		default:i++;
	}
	printf("result= %d\n", i);
 
	return 0;
}
```

12

13

11

14

KEY：B

### **12、以下能对二维数组a进行完整初始化的语句是（）。**

int a[2][3]=((0,1,2),(3,4,5));

int a[2][3]={{0,1,2},{3,4,5}};

int a[2][3]={{0,1},{2,3},{4,5}};

int a[2][3]={0,1,2,3,4};

KEY：B

### **13、下面程序的输出值，正确的是（）。**

```Plain
\#define CALC(x,y) x*y+x
 
int main()
{
	int a = CALC(2 * 3, 3 + 2);
	printf("result= %d\n", a);
 
	return 0;
}
```

26

30

24

36

KEY：A

### **14、下面程序的输出值，正确的是（）。**

```Plain
void swap(int *a, int *b) {
	int *t;
	t = a;
	a = b;
	b = t;
}
 
int main()
{
	int x = 1, y = 2;
	int *p = &x, *q = &y;
	swap(p, q);
	printf("%d %d\n", *p, *q);
 
	return 0;
}
```

1 1

2 2

1 2

2 1

KEY：C

解答：本题的swap函数是将形参中的a、b两个指针指向的地址交换了，实参p、q并没有变化。可以比对一下：

```Plain
int x = 1, y = 2;
 
swap(&x, &y);            //没有效果
void swap(int *a, int *b) {
	int *t;
	t = a;
	a = b;
	b = t;
}
 
swap(&x, &y);            //有效果
void swap(int *a, int *b) {
	int t;
	t = *a;
	*a = *b;
	*b = t;
}
```

### **15、假如test指针的值为0x12345678，则表达式test_p[1]的指针地址值是多少？**

```Plain
char test[8] = { 0x01,0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08 };
int *test_p = (int*)test;
```

0x12345678

0x1234567C

0x12345679

0x1234567A

KEY：B

### **16、在C语言程序中，下面程序运行后，n的值是多少？**

```Plain
int n = 0;
int f = 17;
n = 4 * f % 3 + 1;
```

3

9

2

0

KEY：A

### **17、下面那个操作可以将flag的bit[2]（假定bit[31...0]对应flag的32位）置0？**

flag|=4

flag^=4

flag&=~4

flag|=~4

KEY：C

### **18、下面程序的运行结果为？**

```Plain
\#define TEST(a,b) a*b
 
int main()
{
	int a = TEST(1 + 2, 3);
	printf("result= %d\n", a);
 
	return 0;
}
```

2

3

7

9

KEY：C

### **19、对于堆、栈、队列描述错误的是（）。**

队列空间缓冲由进程申请，栈的空间缓冲由OS分配

堆总是一棵完全二叉树

堆的数据类型和队列相似

队列先进先出，栈后进先出

KEY：B

### **20、以下对字符数组test赋值方式错误的是（）。**

char test[10]; strcpy(test,"test");

char test[10]; test="test";

char test[]={'t','e','s','t'};

char test[10]={'t','e','s','t'};

KEY：B

### **21、可用于中断下半段处理的处理机制有（）。**

tasklet

工作队列

软中断

双向链表

KEY：ABC

解答：**上半部是不能中断的，仅仅是响应中断；下半部是可以中断的。对于适时要求高的，必须放在上半部。下半部的实现主要是通过软中断、tasklet、工作队列来实现的。**

**上半部的功能是响应中断。当中断发生时，它就把设备驱动程序中中断处理例程的下半部挂到设备的下半部执行队列中去，然后继续等待新的中断到来。这样一来，上半部的执行速度就会很快，它就可以接受更多它负责的设备所产生的中断了。**上半部之所以快，是因为它是完全屏蔽中断的，如果它没有执行完，其他中断就不能及时地处理，只能等到这个中断处理程序执行完毕以后。所以要尽可能多的对设备产生的中断进行服务和处理，中断处理程序就一定要快。

**下半部的功能是处理比较复杂的过程。**下半部和上半部最大的区别是可中断，而上半部却不可中断。下半部几乎完成了中断处理程序所有的事情，因为上半部只是将下半部排到了它们所负责的设备中断的处理队列中去，然后就不做其它的处理了。下半部所负责的工作一般是查看设备以获得产生中断的事件信息，并根据这些信息（一般通过读设备上的寄存器得来）进行相应的处理。下半部是可中断的，所以在运行期间，如果其它设备产生了中断，这个下半部可以暂时的中断掉，等到那个设备的上半部运行完了，再回头运行这个下半部。

下面对实现中断下半部工作的3种机制进行总结，便于在实际使用中决定使用哪种机制：

|下半部机制|上下文|复杂度|执行性能|顺序执行保障|
|---|---|---|---|---|
|[[软中断]]|中断|高(需要自己确保软中断的执行顺序及锁机制)|好(全部自己实现，便于调优)|没有|
|[[tasklet]]|中断|中(提供了简单的接口来使用软中断)|中|同类型不能同时执行|
|[[工作队列]]|进程|低(在进程上下文中运行，与写用户程序差不多)|差|没有(和进程上下文一样被调度)|

  
  

参考文章：[如何理解中断的上半部和下半部](https://blog.csdn.net/newtonnl/article/details/46004451)。

### **22、有函数fun()定义如下，在main函数调用fun函数执行过程中，使用了哪些函数参数传递方式？**

```Plain
int fun(int a[], short *ptr, int &c){
        ...
}
```

数组传递

指针传递

引用传递

值传递

KEY：BC

### **23、关于链表，描述正确的选项有（）。**

在运行时可以动态添加

物理空间不连续，空间开销更大

查找元素不需要顺序查找

可在任意节点位置插入元素

KEY：ABD

### **24、对运算符优先级的判断，正确的是（）。**

取余运算符%>加运算符+

逻辑与运算符&&>赋值运算符=

数组下标[]>自增运算符++

左移运算符<<>大于运算符>

KEY：ABCD

### **25、能在Linux内核态执行的是（）。**

缺页中断

时钟中断

命令解释

进程调度

KEY：ABD

解答：**缺页中断和时钟中断都属于中断，在内核态执行。进程调度属于系统调用，在内核态执行，命令解释程序属于命令接口，在用户态执行。**

# **简答题**

### **1、Linux驱动连接硬件与应用，根据你对驱动加载的理解，回答如下问题：**

（1）insmod和modprobe都可以用来加载驱动模块，请描述这两者的差异。

（2）请给出三种以上Linux驱动模块加载失败的可能原因。

解答：modprobe和insmod类似，都是用来动态加载驱动模块的，区别在于modprobe可以解决load module时的依赖关系，它是通过/lib/modules/\#uname -r/modules.dep(.bb)文件来查找依赖关系的；而insmod不能解决依赖问题。

也就是说，如果你确定你要加载的驱动模块不依赖其他驱动模块的话，既可以insmod也可以modprobe，当然insmod可以在任何目录下执行，更方便一些。而如果你要加载的驱动模块还依赖其他ko驱动模块的话，就只能将模块拷贝到上述的特定目录，depmod后再modprobe。

### **2、设计或开发Linux操作系统的内核时，你会考虑哪些基本的管理模块，并描述其作用。**

解答：**Linux内核的五大模块：进程调度模块、内存管理模块、文件系统模块、进程间通信模块、网络接口模块。**

- 进程调度模块：用来负责控制进程对CPU 资源的使用。所采取的调度策略是各进程能够公平合理地访问CPU，同时保证内核能及时地执行硬件操作；
- 内存管理模块：用于确保所有进程能够安全地共享机器主内存区，同时，内存管理模块还支持虚拟内存管理方式，使得Linux 支持进程使用比实际内存空间更多的内存容量。并可以利用文件系统，对暂时不用的内存数据块交换到外部存储设备上去，当需要时再交换回来；
- 文件系统模块：用于支持对外部设备的驱动和存储。虚拟文件系统模块通过向所有的外部存储设备提供一个通用的文件接口，隐藏了各种硬件设备的不同细节。从而提供并支持与其它操作系统兼容的多种文件系统格式；
- 进程间通信模块：用于支持多种进程间的信息交换方式；
- 网络接口模块：提供对多种网络通信标准的访问并支持许多网络硬件。

任职要求

IIC

SPI

UART

架构

操作系统原理

陷阱

故障

终止

进程

进程之间通信（IPC）

线程同步

static

const

volatile

指针数组/数组指针

一、数据结构(二叉树，链表，队列，栈)，手写链表的插入，中间插入

二、GDB用过吗，具体解决问题的实例

三、socket通信的过程，全部函数写一下

选择题

1、若有8个待排序元素，采用冒泡排序和插入排序最大时间复杂度分别是（）。

2、下面程序中b的值是（）。

3、下列代码中数组data最终的数据是哪个（）。

4、下面哪个命令用来卸载一个内核模块？

5、使用快速排序对n个数进行排序，其在最佳情况、平均情况、最差情况下的时间复杂度分别是（）。

6、关于互斥锁的如下表述错误的是（）。

7、Linux在某目录下查找某字符串通常如下哪个指令？

8、多个进程按照顺序逐一来访问某个资源，这种制约关系称之为（）。

9、支持多道程序的操作系统在运行过程中，不断地选择新进程运行来实现CPU的共享，但其中（）不是引起操作系统选择新进程的直接原因。

10、（）是操作系统分配资源的基本单位。

11、执行下述的main函数后，输出结果是多少？

12、以下能对二维数组a进行完整初始化的语句是（）。

13、下面程序的输出值，正确的是（）。

14、下面程序的输出值，正确的是（）。

15、假如test指针的值为0x12345678，则表达式test_p[1]的指针地址值是多少？

16、在C语言程序中，下面程序运行后，n的值是多少？

17、下面那个操作可以将flag的bit[2]（假定bit[31...0]对应flag的32位）置0？

18、下面程序的运行结果为？

19、对于堆、栈、队列描述错误的是（）。

20、以下对字符数组test赋值方式错误的是（）。

21、可用于中断下半段处理的处理机制有（）。

22、有函数fun()定义如下，在main函数调用fun函数执行过程中，使用了哪些函数参数传递方式？

23、关于链表，描述正确的选项有（）。

24、对运算符优先级的判断，正确的是（）。

25、能在Linux内核态执行的是（）。

简答题

1、Linux驱动连接硬件与应用，根据你对驱动加载的理解，回答如下问题：

2、设计或开发Linux操作系统的内核时，你会考虑哪些基本的管理模块，并描述其作用。

[[计算机控制]]