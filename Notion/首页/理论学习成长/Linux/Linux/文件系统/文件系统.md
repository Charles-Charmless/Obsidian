磁盘

格式化

1. inode table

2. data block

3. superblock

4. Filesystem Description

5. block bitmap

6. inode bitmap

目录结构

目录层次

[[Copy of Linux文件系统详解 - 掘金]]

  

## 磁盘

磁盘的构成：

磁盘→盘片→磁道→扇区→存储颗粒

磁道→柱面（分区的最小单元）

扇区→簇（由文件系统决定，文件系统中的最小存储单元）

机械硬盘能实现信息存储的功能基于：磁性存储介质能够被磁化，且磁化后会长久保留被磁化的状态，这种被磁化状态能够被读取出来，同时这种磁化状态还能够不断被修改，磁化正好有两个方向，所以可以表示0和1。于是硬盘就是把这种磁性存储介质做成一个个盘片，每一个盘片上都分布着数量巨大的磁性存储单位，使用磁性读写头对盘片进行写入和读取（从原理上类似黑胶唱片的播放）。

  

一个硬盘有多张盘片叠成，不同盘片有编号

每张盘片上的存储颗粒成环形一圈圈地排布，每一圈称为磁道，有编号

每条磁道上都有一圈存储颗粒，每512*8（512字节，0.5KB）个存储颗粒作为一个扇区，扇区是硬盘上存储的最小物理单位

N个扇区可以组成簇，N取决于不同的文件系统或是文件系统的配置，簇是此文件系统中的最小存储单位

所有盘面上的同一磁道构成一个圆柱，称为柱面，柱面是系统分区的最小单位

  

磁头读写文件的时候，首先是分区读写的，由inode编号（区内唯一的编号后面介绍）找到对应的磁道和扇区，然后一个柱面一个柱面地进行读写。机械硬盘的读写控制系统是一个令人叹为观止的精密工程（一个盘面上有几亿个存储单位，每个磁道宽度不到几十纳米，磁盘每分钟上万转），同时关于读写的逻辑也是有诸多细节（比如扇区的编号并不是连续的），非常有意思，可以自行搜索文章拓展阅读。

有了硬盘并不意味着LInux可以立刻把它用来存储，还需要组合进Linux的文件体系才能被Linux使用。

  

Linux 的文件系统形成一个层级结构的目录树

硬盘首先进行分区，将磁盘这个物理概念转换成区这个逻辑概念，为格式化做准备，分区要提到硬盘上最重要的第一扇区，该扇区中包含硬件主引导记录（MBR）以及分区表，其中 MBR 占有 446 bytes，而分区表占有 64 bytes。硬盘主引导记录放有最基本的引导加载程序，是系统开机启动的关键环节，在附录中有更详细的说明。而分区表则跟分区有关，它记录了硬盘分区的相关信息，但因分区表仅有 64bytes ， 所以最多只能记彔四块分区（分区本身其实就是对分区表进行设置）。

由于四块分区太小，所以用额外的扇区来记录更多的分区信息，就有了扩展分区的概念。

  

MBR,分区表→主分区(4个)→扩展分区(1个)→逻辑分区

扩展分区只是逻辑概念，本身不能被访问，也就是不能被格式化后作为数据访问的分区，能够作为数据访问的分区只有主分区和逻辑分区

  

swap区：当有数据被存放在物理内存里面，但是这些数据又不是常被 CPU 所取用时，那么这些不常被使用的程序将会被丢到硬盘的 swap 置换空间当中， 而将速度较快的物理内存空间释放出来给真正需要的程序使用

  

  

## 格式化

linux将对不同文件系统的访问交给了VFS（虚拟文件系统），VFS能访问和管理各种不同的文件系统。所以有了区之后就需要把它格式化成具体的文件系统以便VFS访问。

  

linux文件系统基于inode，

文件系统通常会将属性和实际内容这两部分数据分别存放在不同的区块

在基于inode的文件系统中，权限与属性放置到 inode 中，实际数据放到 data block 区块中，而且inode和data block都有编号

文件系统最前面有一个启动扇区(boot sector)

这个启动扇区可以安装开机管理程序， 这个设计让我们能将不同的引导装载程序安装到个别的文件系统前端，而不用覆盖整个硬盘唯一的MBR， 也就是这样才能实现多重引导的功能

把每个区进一步分为多个块组 (block group)，每个块组有独立的inode/block体系

每个块组实际还会分为分为6个部分，除了inode table 和 data block外还有4个附属模块，起到优化和完善系统性能的作用

  

### 1. inode table

主要记录文件的属性以及该文件实际数据是放置在哪些block中，它记录的信息至少有这些：  
大小、真正内容的block号码（一个或多个）  
访问模式(read/write/excute)  
拥有者与群组(owner/group)  
各种时间：建立或状态改变的时间、最近一次的读取时间、最近修改的时间  
没有文件名！文件名在目录的block中！  
一个文件占用一个 inode，每个inode有编号  
Linux 系统存在 inode 号被用完但磁盘空间还有剩余的情况  
注意，这里的文件不单单是普通文件，目录文件也就是文件夹其实也是一个文件，还有其他的也是  
inode 的数量与大小在格式化时就已经固定了，每个inode 大小均固定为128 bytes (新的ext4 与xfs 可设定到256 bytes)  
文件系统能够建立的文件数量与inode 的数量有关，存在空间还够但inode不够的情况  
系统读取文件时需要先找到inode，并分析inode 所记录的权限与使用者是否符合，若符合才能够开始实际读取 block 的内容  
inode 要记录的资料非常多，但偏偏又只有128bytes ， 而inode 记录一个block 号码要花掉4byte ，假设我一个文件有400MB 且每个block 为4K 时， 那么至少也要十万条block 号码的记录！inode 哪有这么多空间来存储？为此我们的系统很聪明的将inode 记录block 号码的区域定义为12个直接，一个间接, 一个双间接与一个三间接记录区（详细见附录）  

### 2. data block

放置文件内容数据的地方  
在格式化时block的大小就固定了，且每个block都有编号，以方便inode的记录  
原则上，block 的大小与数量在格式化完就不能够再改变了(除非重新格式化)  
在Ext2文件系统中所支持的block大小有1K, 2K及4K三种，由于block大小的区别，会导致该文件系统能够支持的最大磁盘容量与最大单一文件容量各不相同：  
Block 大小 1KB 2KB 4KB  
最大单一档案限制 16GB 256GB 2TB  
最大档案系统总容量 2TB 8TB 16TB  
每个block 内最多只能够放置一个文件的资料，但一个文件可以放在多个block中（大的话）  
若文件小于block ，则该block 的剩余容量就不能够再被使用了(磁盘空间会浪费)  
所以如果你的档案都非常小，但是你的block 在格式化时却选用最大的4K 时，可能会产生容量的浪费  
既然大的block 可能会产生较严重的磁碟容量浪费，那么我们是否就将block 大小定为1K ？这也不妥，因为如果block 较小的话，那么大型档案将会占用数量更多的block ，而inode 也要记录更多的block 号码，此时将可能导致档案系统不良的读写效能  
事实上现在的磁盘容量都太大了，所以一般都会选择4K 的block 大小  

### 3. superblock

记录整个文件系统相关信息的地方，一般大小为1024bytes，记录的信息主要有：  
block 与inode 的总量  
未使用与已使用的inode / block 数量  
一个valid bit 数值，若此文件系统已被挂载，则valid bit 为0 ，若未被挂载，则valid bit 为1  
block 与inode 的大小 (block 为1, 2, 4K，inode 为128bytes 或256bytes)；  
其他各种文件系统相关信息：filesystem 的挂载时间、最近一次写入资料的时间、最近一次检验磁碟(fsck) 的时间  
Superblock是非常重要的， 没有Superblock ，就没有这个文件系统了，因此如果superblock死掉了，你的文件系统可能就需要花费很多时间去挽救  
每个块都可能含有superblock，但是我们也说一个文件系统应该仅有一个superblock 而已，那是怎么回事？事实上除了第一个块内会含有superblock 之外，后续的块不一定含有superblock，而若含有superblock则该superblock主要是做为第一个块内superblock的备份，这样可以进行superblock的救援  

### 4. Filesystem Description

文件系统描述  
这个区段可以描述每个block group的开始与结束的block号码，以及说明每个区段(superblock, bitmap, inodemap, data block)分别介于哪一个block号码之间  

### 5. block bitmap

块对照表  
如果你想要新增文件时要使用哪个block 来记录呢？当然是选择「空的block」来记录。那你怎么知道哪个block 是空的？这就得要通过block bitmap了，它会记录哪些block是空的，因此我们的系统就能够很快速的找到可使用的空间来记录  
同样在你删除某些文件时，那些文件原本占用的block号码就得要释放出来， 此时在block bitmap 中对应该block号码的标志位就得要修改成为「未使用中」  

### 6. inode bitmap

与block bitmap 是类似的功能，只是block bitmap 记录的是使用与未使用的block 号码， 至于inode bitmap 则是记录使用与未使用的inode 号码

  

  

  

  

  

  

## 目录结构

|目录|存放文件的内容|
|---|---|
|[[-boot]]|启动目录，存放启动文件|
|[[-dev]]|设备目录，linux在这里创建设备节点|
|[[-etc]]|系统配置文件目录|
|[[-home]]|主目录，linux在这里创建用户目录|
|[[-lib]]|库目录，存放系统和应用程序的库文件|
|[[-lib64]]|64位库|
|[[-media]]|媒体目录，存放可移动媒体设备挂载点的地方|
|[[-mnt]]|挂载目录，另一个可以存放可移动媒体设备挂载点的地方|
|[[-opt]]|可选目录，通常用于存放可选的软件包|
|[[-proc]]|用来提供内核与进程信息的虚拟文件系统|
|[[-root]]|系统管理员的主目录|
|[[-srv]]||
|[[-sys]]||
|[[-tmp]]|临时目录，可以在该目录中创建和删除临时文件|
|[[-usr]]|用户安装软件的目录|
|[[-var]]|可变目录，用以存放经常变化的文件，如日志文件|

  
  

## 目录层次

  

由上而下主要分为用户层、VFS层、文件系统层、缓存层、块设备层、磁盘驱动层、磁盘物理层

用户层：最上面用户层就是我们日常使用的各种程序，需要的接口主要是文件的创建、删除、打开、关闭、写、读等。

VFS层：我们知道Linux分为用户态和内核态，用户态请求硬件资源需要调用System Call通过内核态去实现。用户的这些文件相关操作都有对应的System Call函数接口，接口调用 VFS对应的函数。

文件系统层：不同的文件系统实现了VFS的这些函数，通过指针注册到VFS里面。所以，用户的操作通过VFS转到各种文件系统。文件系统把文件读写命令转化为对磁盘LBA的操作，起了一个翻译和磁盘管理的作用。

缓存层：文件系统底下有缓存，Page Cache，加速性能。对磁盘LBA的读写数据缓存到这里。

块设备层：块设备接口Block Device是用来访问磁盘LBA的层级，读写命令组合之后插入到命令队列，磁盘的驱动从队列读命令执行。Linux设计了电梯算法等对很多LBA的读写进行优化排序，尽量把连续地址放在一起。

磁盘驱动层：磁盘的驱动程序把对LBA的读写命令转化为各自的协议，比如变成ATA命令，SCSI命令，或者是自己硬件可以识别的自定义命令，发送给磁盘控制器。Host Based SSD甚至在块设备层和磁盘驱动层实现了FTL，变成对Flash芯片的操作。

磁盘物理层：读写物理数据到磁盘介质。

![[1066890-20170310203951826-1382904803.png]]